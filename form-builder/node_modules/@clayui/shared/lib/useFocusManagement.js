"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFocusManagement = useFocusManagement;

var _react = _interopRequireDefault(require("react"));

var _Keys = require("./Keys");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * SPDX-FileCopyrightText: Â© 2019 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: BSD-3-Clause
 */
// https://github.com/facebook/react/blob/master/packages/shared/ReactWorkTags.js#L39
var HostComponent = 5;

function useFocusManagement(scope) {
  var nextElementOutsideScopeRef = _react.default.useRef(null); // https://github.com/facebook/react/pull/15849#diff-39a673d38713257d5fe7d90aac2acb5aR107


  var isFiberHostComponentFocusable = function isFiberHostComponentFocusable(fiber) {
    if (fiber.tag !== HostComponent) {
      return false;
    }

    var memoizedProps = fiber.memoizedProps,
        stateNode = fiber.stateNode,
        type = fiber.type; // Hack to check if element is visible

    if (!stateNode.offsetParent) {
      return false;
    }

    if (memoizedProps.disabled) {
      return false;
    }

    var minTabIndex = 0;

    if (memoizedProps.tabIndex != null && memoizedProps.tabIndex >= minTabIndex || memoizedProps.contentEditable === true) {
      return true;
    }

    if (type === 'a' || type === 'area') {
      return !!memoizedProps.href && memoizedProps.rel !== 'ignore';
    }

    if (type === 'input') {
      return memoizedProps.type !== 'hidden' && memoizedProps.type !== 'file';
    }

    return type === 'button' || type === 'textarea' || type === 'object' || type === 'select' || type === 'iframe' || type === 'embed';
  };

  var collectFocusableElements = function collectFocusableElements(node, focusableElements) {
    if (isFiberHostComponentFocusable(node)) {
      focusableElements.push(node.stateNode);
    }

    var child = node.child;

    if (child !== null) {
      collectFocusableElements(child, focusableElements);
    }

    var sibling = node.sibling;

    if (sibling) {
      collectFocusableElements(sibling, focusableElements);
    }
  };

  var getFiber = function getFiber(scope) {
    if (!scope.current) {
      return null;
    }

    var internalKey = Object.keys(scope.current).find(function (key) {
      return key.indexOf('__reactInternalInstance') === 0;
    });

    if (internalKey) {
      return scope.current[internalKey];
    }

    return null;
  };

  var getFocusableElementsInScope = function getFocusableElementsInScope(fiberNode) {
    var focusableElements = [];
    var child = fiberNode.child;

    if (child !== null) {
      collectFocusableElements(child, focusableElements);
    }

    return focusableElements;
  };

  var handleNextElementOutsideScope = function handleNextElementOutsideScope(event) {
    // Ignores the call for cases where the element's children have tabIndex.
    if (nextElementOutsideScopeRef.current !== event.target) {
      return;
    }

    if (nextElementOutsideScopeRef.current !== event.currentTarget) {
      event.currentTarget.removeEventListener('keydown', handleNextElementOutsideScope);
      return;
    }

    if (event.key === _Keys.Keys.Tab && event.shiftKey) {
      var elements = getFocusableElementsInScope(getFiber(scope));

      if (elements.length === 0) {
        if (event.currentTarget) {
          event.currentTarget.removeEventListener('keydown', handleNextElementOutsideScope);
        }

        return;
      }

      event.preventDefault();
      elements[elements.length - 1].focus();
    }
  };

  var setInteractionObserver = function setInteractionObserver(element) {
    if (nextElementOutsideScopeRef.current !== null) {
      nextElementOutsideScopeRef.current.removeEventListener('keydown', handleNextElementOutsideScope);
    }

    nextElementOutsideScopeRef.current = element;
    nextElementOutsideScopeRef.current.addEventListener('keydown', handleNextElementOutsideScope);
  };

  var getElementEdge = function getElementEdge(fiberNode, backwards) {
    var focusableElementsEdge = [];
    var fiberNodeReturn = fiberNode.return;

    if (fiberNodeReturn !== null) {
      collectFocusableElements(fiberNodeReturn, focusableElementsEdge);
    }

    if (!focusableElementsEdge.length) {
      return null;
    }

    var nodePosition = focusableElementsEdge.findIndex(function (el) {
      return document.activeElement === el;
    });
    var nextElement = null;

    if (backwards) {
      nextElement = focusableElementsEdge[nodePosition - 1];
    } else {
      nextElement = focusableElementsEdge[nodePosition + 1];
    }

    if (!nextElement && fiberNodeReturn.return) {
      return getElementEdge(fiberNodeReturn.return, backwards);
    }

    return nextElement;
  };

  var moveFocusInScope = function moveFocusInScope(scope) {
    var backwards = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var elements = getFocusableElementsInScope(scope);

    if (elements.length === 0) {
      return null;
    }

    var node = document.activeElement;

    if (!node) {
      return;
    }

    var position = elements.indexOf(node);
    var lastPosition = elements.length - 1;
    var nextElement = null; // Ignore when the active element is not in the scope.

    if (position < 0) {
      return null;
    }

    if (backwards) {
      if (position === 0) {
        // is out of scope, so we go back through the fiber to pick up the
        // focusable elements from the scopes edge.
        nextElement = getElementEdge(scope, backwards);
      } else {
        nextElement = elements[position - 1];
      }
    } else {
      if (position === lastPosition) {
        // is out of scope, so we go back through the fiber to pick up the
        // focusable elements from the scopes edge.
        nextElement = getElementEdge(scope, backwards); // Control the tab + shift keydown of the element next to the scope to
        // return the focus to the last scopo element, this is necessary for
        // when have React Portal.

        if (nextElement) {
          setInteractionObserver(nextElement);
        }
      } else {
        nextElement = elements[position + 1];
      }
    }

    if (nextElement) {
      nextElement.focus();
      return nextElement;
    }

    return null;
  };

  _react.default.useEffect(function () {
    if (nextElementOutsideScopeRef.current) {
      nextElementOutsideScopeRef.current.removeEventListener('keydown', handleNextElementOutsideScope); // Sets the value to null only to remove reference and prevent
      // memory leak cases.

      nextElementOutsideScopeRef.current = null;
    }
  }, [scope]);

  return {
    focusNext: function focusNext() {
      return moveFocusInScope(getFiber(scope));
    },
    focusPrevious: function focusPrevious() {
      return moveFocusInScope(getFiber(scope), true);
    }
  };
}